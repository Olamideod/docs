---
title: "Authentication API"
sidebarTitle: "Authentication"
description: "Exchange authorization codes for tokens, refresh access, and handle user logout"
---

## Overview

The Authentication API handles OAuth 2.0 token operations. After your application redirects users to Protekt for login, you will receive an authorization code. Now we will use this API to exchange that code for access tokens, refresh expired tokens when needed, and revoke tokens when users log out.

This API implements the standard OAuth 2.0 authorization code flow. Your app never sees user passwords, because Protekt handles authentication, then returns secure tokens your app uses to make API calls on behalf of users.


**Base URL:** `https://api.protekt.com/v1`

<Tip>
**Authentication:** All endpoints require your client credentials (client ID and secret).
</Tip>


## Endpoints and methods

| Method | Endpoint | Purpose | Rate Limit |
|--------|----------|---------|------------|
| POST | `/oauth/token` | Exchange authorization code for access and refresh tokens | 10/min |
| POST | `/oauth/refresh` | Get new access token using refresh token | 30/min |
| POST | `/oauth/revoke` | Invalidate tokens when user logs out | 20/min |


## Exchange authorization code

After a user successfully authenticates with Protekt, they're redirected back to your app with an authorization code in the URL. This endpoint exchanges that short-lived code for access and refresh tokens you'll use to make API calls.

**Endpoint:** `POST /oauth/token`

### Parameters

The request body should be JSON with these parameters:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `grant_type` | string | Yes | Must be `authorization_code` |
| `code` | string | Yes | The authorization code from the redirect URL query parameter |
| `redirect_uri` | string | Yes | Must exactly match the redirect URI you used when initiating the OAuth flow |
| `client_id` | string | Yes | Your application's client ID from the Protekt dashboard |
| `client_secret` | string | Yes | Your application's client secret from the Protekt dashboard |
| `code_verifier` | string | No | PKCE code verifier if you're using PKCE flow (recommended for mobile and SPAs) |

**Headers required:**

```
Content-Type: application/json
```

<Info>
**About PKCE:** If you're building a mobile app or single-page application that can't securely store a client secret, use PKCE (Proof Key for Code Exchange) instead. In PKCE flow, you don't send `client_secret`, but you do send the `code_verifier` that matches the `code_challenge` you sent when starting the OAuth flow. See the [PKCE authentication guide](../concepts/authentication-flows#pkce) for details.
</Info>

<Accordion title="Request & Response Example">
### Request example

Here's how to exchange an authorization code for tokens:

```bash cURL
curl -X POST https://api.protekt.com/v1/oauth/token \
  -H "Content-Type: application/json" \
  -d '{
    "grant_type": "authorization_code",
    "code": "auth_abc123_received_from_redirect",
    "redirect_uri": "https://yourapp.com/callback",
    "client_id": "your_client_id_here",
    "client_secret": "your_client_secret_here"
  }'
```

```javascript Node.js
const fetch = require('node-fetch');

const response = await fetch('https://api.protekt.com/v1/oauth/token', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    grant_type: 'authorization_code',
    code: 'auth_abc123_received_from_redirect',
    redirect_uri: 'https://yourapp.com/callback',
    client_id: 'your_client_id_here',
    client_secret: 'your_client_secret_here'
  })
});

const tokens = await response.json();
console.log('Access token:', tokens.access_token);

// Store these tokens securely
// accessToken = tokens.access_token;
// refreshToken = tokens.refresh_token;
```

```python Python
import requests

response = requests.post(
    'https://api.protekt.com/v1/oauth/token',
    json={
        'grant_type': 'authorization_code',
        'code': 'auth_abc123_received_from_redirect',
        'redirect_uri': 'https://yourapp.com/callback',
        'client_id': 'your_client_id_here',
        'client_secret': 'your_client_secret_here'
    }
)

tokens = response.json()
print(f"Access token: {tokens['access_token']}")

# Store these tokens securely
# access_token = tokens['access_token']
# refresh_token = tokens['refresh_token']
```
</Accordion>

<Warning>
**Important:** Authorization codes expire after 60 seconds and can only be used once. If you get an `invalid_grant` error, the code has already been used or expired. Start the OAuth flow again to get a new code.
</Warning>

**Error responses:**

If something goes wrong, you'll receive an error response with an HTTP status code and error details:

| Status | Error Code | What it means | How to fix |
|--------|------------|---------------|------------|
| 400 | `invalid_grant` | The authorization code is invalid, expired, or already used | Start a new OAuth flow to get a fresh authorization code |
| 400 | `invalid_request` | Required parameter is missing or malformed | Check that all required fields are present and properly formatted |
| 400 | `redirect_uri_mismatch` | The redirect_uri doesn't match what was used during authorization | Use the exact same redirect_uri you used when starting the OAuth flow |
| 401 | `invalid_client` | Client credentials are wrong | Double-check your client_id and client_secret in the dashboard |

Example error response:

```json
{
  "error": "invalid_grant",
  "error_description": "Authorization code has expired"
}
```

## Refresh access token

Access tokens expire after one hour for security. Rather than making users log in again, use the refresh token to get a new access token. Your app should refresh tokens automatically before they expire, don't wait for API calls to fail with 401 errors.

**Endpoint:** `POST /oauth/refresh`

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `grant_type` | string | Yes | Must be `refresh_token` |
| `refresh_token` | string | Yes | The refresh token you received from the initial token exchange |
| `client_id` | string | Yes | Your application's client ID |
| `client_secret` | string | Yes | Your application's client secret |

**Headers required:**

```
Content-Type: application/json
```

### Request example

<CodeGroup>

```bash cURL
curl -X POST https://api.protekt.com/v1/oauth/refresh \
  -H "Content-Type: application/json" \
  -d '{
    "grant_type": "refresh_token",
    "refresh_token": "refresh_token_xyz789",
    "client_id": "your_client_id_here",
    "client_secret": "your_client_secret_here"
  }'
```
```javascript Node.js
const response = await fetch('https://api.protekt.com/v1/oauth/refresh', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    grant_type: 'refresh_token',
    refresh_token: refreshToken,
    client_id: 'your_client_id_here',
    client_secret: 'your_client_secret_here'
  })
});

const newTokens = await response.json();

// Update your stored tokens
accessToken = newTokens.access_token;
// Important: Store the new refresh token if one is returned
if (newTokens.refresh_token) {
  refreshToken = newTokens.refresh_token;
}
```

```python Python
response = requests.post(
    'https://api.protekt.com/v1/oauth/refresh',
    json={
        'grant_type': 'refresh_token',
        'refresh_token': refresh_token,
        'client_id': 'your_client_id_here',
        'client_secret': 'your_client_secret_here'
    }
)

new_tokens = response.json()

# Update your stored tokens
access_token = new_tokens['access_token']
# Important: Store the new refresh token if one is returned
if 'refresh_token' in new_tokens:
    refresh_token = new_tokens['refresh_token']
```

</CodeGroup>

Using the SDK:

```javascript Node.js SDK
const newTokens = await protekt.refreshToken(refreshToken);

// Update stored tokens
accessToken = newTokens.accessToken;
if (newTokens.refreshToken) {
  refreshToken = newTokens.refreshToken;
}
```

### Response example and schema

**Success response (200 OK):**

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.new_token_here",
  "refresh_token": "new_refresh_token_abc456",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

**Response fields:**

| Field | Type | Always present? | Description |
|-------|------|-----------------|-------------|
| `access_token` | string | Yes | New JWT access token. Replace your old one with this |
| `refresh_token` | string | Sometimes | New refresh token. If present, this replaces your old refresh token (token rotation for security) |
| `token_type` | string | Yes | Always `Bearer` |
| `expires_in` | integer | Yes | Seconds until the new access token expires (typically 3600) |

<Tip>
**Refresh token rotation:** For security, Protekt may return a new refresh token when you refresh an access token. If you receive a `refresh_token` field in the response, store it and use it for future refresh requests. The old refresh token is now invalid.
</Tip>

**Error responses:**

| Status | Error Code | What it means | How to fix |
|--------|------------|---------------|------------|
| 400 | `invalid_grant` | Refresh token is invalid or expired | User must log in again. Redirect them to start a new OAuth flow |
| 401 | `invalid_client` | Client credentials are incorrect | Verify your client_id and client_secret |


## Revoke token

When a user logs out of your application, call this endpoint to revoke their tokens. This immediately invalidates the tokens so they can't be used for API calls.

If you revoke a refresh token, all access tokens issued from that refresh token are also revoked. If you revoke an access token, only that specific access token is invalidated.

**Endpoint:** `POST /oauth/revoke`

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `token` | string | Yes | The access token or refresh token to revoke |
| `token_type_hint` | string | No | Either `access_token` or `refresh_token`. Helps the server process the request faster |
| `client_id` | string | Yes | Your application's client ID |
| `client_secret` | string | Yes | Your application's client secret |

**Headers required:**

```
Content-Type: application/json
```

### Request example

<CodeGroup>

```bash cURL
curl -X POST https://api.protekt.com/v1/oauth/revoke \
  -H "Content-Type: application/json" \
  -d '{
    "token": "refresh_token_xyz789",
    "token_type_hint": "refresh_token",
    "client_id": "your_client_id_here",
    "client_secret": "your_client_secret_here"
  }'
```

```javascript Node.js
const response = await fetch('https://api.protekt.com/v1/oauth/revoke', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    token: refreshToken,
    token_type_hint: 'refresh_token',
    client_id: 'your_client_id_here',
    client_secret: 'your_client_secret_here'
  })
});

// Clear stored tokens after successful revocation
if (response.ok) {
  accessToken = null;
  refreshToken = null;
  console.log('User logged out successfully');
}
```

```python Python
response = requests.post(
    'https://api.protekt.com/v1/oauth/revoke',
    json={
        'token': refresh_token,
        'token_type_hint': 'refresh_token',
        'client_id': 'your_client_id_here',
        'client_secret': 'your_client_secret_here'
    }
)

# Clear stored tokens after successful revocation
if response.ok:
    access_token = None
    refresh_token = None
    print('User logged out successfully')
```

</CodeGroup>

Using the SDK:

```javascript Node.js SDK
await protekt.revokeToken(refreshToken);

// Clear stored tokens
accessToken = null;
refreshToken = null;
```

### Response example and schema

**Success response (200 OK):**

```json
{
  "revoked": true
}
```

The response is simple if the token was successfully revoked, you will get a 200 status with `"revoked": true`.

<Tip>
**Best practice:** Always revoke the refresh token, not the access token. When you revoke a refresh token, Protekt automatically revokes all associated access tokens. This ensures the user is fully logged out across all their sessions.
</Tip>

**Error responses:**

| Status | Error Code | What it means | How to fix |
|--------|------------|---------------|------------|
| 401 | `invalid_client` | Client credentials are incorrect | Verify your client_id and client_secret |
| 400 | `unsupported_token_type` | Token format is not recognized | Make sure you're sending a valid Protekt token |

## Common implementation patterns

Here are practical examples for handling tokens in production applications.

### Automatically refresh expired tokens

Don't wait for API calls to fail with 401 errors. Proactively refresh tokens before they expire:

```javascript
// Store expiration time when you receive tokens
let tokenExpiresAt = Date.now() + (expiresIn * 1000);

// Before making any API call, check if token needs refresh
async function makeApiCall(url, options = {}) {
  // Refresh if token expires in less than 5 minutes
  const fiveMinutes = 5 * 60 * 1000;
  if (Date.now() + fiveMinutes > tokenExpiresAt) {
    const newTokens = await refreshAccessToken();
    accessToken = newTokens.access_token;
    tokenExpiresAt = Date.now() + (newTokens.expires_in * 1000);
  }
  
  // Now make the API call with fresh token
  const response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${accessToken}`
    }
  });
  
  return response.json();
}
```

### Handle token refresh failures

If refreshing fails (refresh token expired or revoked), redirect the user to log in again:

```javascript server.js
async function refreshAccessToken() {
  try {
    const response = await fetch('https://api.protekt.com/v1/oauth/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: 'your_client_id_here',
        client_secret: 'your_client_secret_here'
      })
    });
    
    if (!response.ok) {
      // Refresh token invalid or expired
      // Clear tokens and redirect to login
      accessToken = null;
      refreshToken = null;
      window.location.href = '/login?reason=session_expired';
      return;
    }
    
    return await response.json();
  } catch (error) {
    console.error('Token refresh failed:', error);
    window.location.href = '/login?reason=session_expired';
  }
}
```

### Complete logout flow

When implementing logout, revoke tokens and clear local storage:

```javascript
async function logout() {
  try {
    // Revoke the refresh token on the server
    await fetch('https://api.protekt.com/v1/oauth/revoke', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        token: refreshToken,
        token_type_hint: 'refresh_token',
        client_id: 'your_client_id_here',
        client_secret: 'your_client_secret_here'
      })
    });
  } catch (error) {
    console.error('Token revocation failed:', error);
  } finally {
    // Always clear local tokens, even if revocation failed
    accessToken = null;
    refreshToken = null;
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    
    // Redirect to login page
    window.location.href = '/login';
  }
}
```


## Rate limits

To prevent abuse, Protekt rate-limits authentication endpoints per client ID:

- **Token exchange:** 10 requests per minute
- **Token refresh:** 30 requests per minute
- **Token revocation:** 20 requests per minute

If you exceed these limits, you'll receive a `429 Too Many Requests` response with a `Retry-After` header indicating how many seconds to wait before retrying.

```json
{
  "error": "rate_limit_exceeded",
  "error_description": "Rate limit exceeded. Retry after 45 seconds.",
  "retry_after": 45
}
```

In production, implement exponential backoff when you hit rate limits.


## Security best practices

<Warning>
**Critical security requirements:**

- **Never expose your client secret in frontend code.** Client secrets should only be used in backend/server-side code. For mobile apps and SPAs, use PKCE flow instead.
- **Store refresh tokens securely.** Use httpOnly cookies for web apps, or encrypted storage for mobile apps. Never store tokens in localStorage where JavaScript can access them.
- **Always use HTTPS.** All token endpoints require HTTPS in production. HTTP is only allowed for localhost development.
- **Implement PKCE for public clients.** Mobile apps and single-page applications can't securely store a client secret. Use PKCE (Proof Key for Code Exchange) instead, see the [PKCE guide](../concepts/authentication-flows#pkce).
- **Refresh proactively, not reactively.** Don't wait for 401 errors. Refresh tokens 5 minutes before they expire to prevent disrupted user experience.
</Warning>

