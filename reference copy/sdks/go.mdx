---
title: "Go SDK"
description: "Official Go SDK for Protekt authentication and authorization"
---

# Go SDK

The official Go SDK for Protekt provides a simple and secure way to integrate authentication and authorization into your Go applications.

## Installation

```bash
go get github.com/protekt/go
```

## Quick Start

```go
package main

import (
    "fmt"
    "log"
    "github.com/protekt/go"
)

func main() {
    client := protekt.NewClient(&protekt.Config{
        Domain:       "your-tenant.protekt.com",
        ClientID:     "your-client-id",
        ClientSecret: "your-client-secret",
    })

    // Authenticate a user
    user, err := client.Auth.Login(&protekt.LoginRequest{
        Email:    "user@example.com",
        Password: "password123",
    })
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("User authenticated: %+v\n", user)
}
```

## Configuration

### Initialize the Client

```go
client := protekt.NewClient(&protekt.Config{
    Domain:       "your-tenant.protekt.com",      // Your Protekt domain
    ClientID:     "your-client-id",               // Your application client ID
    ClientSecret: "your-client-secret",           // Your application client secret
    RedirectURI:  "http://localhost:3000/callback", // OAuth redirect URI
    Scope:        "openid profile email",         // OAuth scopes
})
```

### Environment Variables

You can also configure the client using environment variables:

```bash
export PROTEKT_DOMAIN=your-tenant.protekt.com
export PROTEKT_CLIENT_ID=your-client-id
export PROTEKT_CLIENT_SECRET=your-client-secret
export PROTEKT_REDIRECT_URI=http://localhost:3000/callback
```

```go
client := protekt.NewClient(nil) // Uses environment variables automatically
```

## Authentication

### Password-based Authentication

```go
// Login with email and password
result, err := client.Auth.Login(&protekt.LoginRequest{
    Email:    "user@example.com",
    Password: "password123",
})
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Access token: %s\n", result.AccessToken)
fmt.Printf("User: %+v\n", result.User)
```

### Social Login

```go
// Login with Google
result, err := client.Auth.LoginWithProvider("google")

// Login with GitHub
result, err := client.Auth.LoginWithProvider("github")
```

### OAuth Flow

```go
// Generate authorization URL
authURL := client.Auth.GetAuthorizationURL(&protekt.AuthorizationURLRequest{
    Scope: "openid profile email",
    State: "random-state-string",
})

// Handle callback
tokens, err := client.Auth.HandleCallback(r.URL.Query())

// Get user profile
user, err := client.Auth.GetUser(tokens.AccessToken)
```

### Magic Link Authentication

```go
// Send magic link
err := client.Auth.SendMagicLink(&protekt.MagicLinkRequest{
    Email:       "user@example.com",
    RedirectURI: "http://localhost:3000/verify",
})

// Verify magic link token
user, err := client.Auth.VerifyMagicLink(token)
```

## User Management

### Get User Profile

```go
user, err := client.Users.GetProfile(accessToken)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("User: %+v\n", user)
```

### Update User Profile

```go
updatedUser, err := client.Users.UpdateProfile(accessToken, &protekt.UpdateUserRequest{
    Name:   "John Doe",
    Picture: "https://example.com/avatar.jpg",
})
```

### Get User by ID

```go
user, err := client.Users.GetByID("user-id")
```

## Organizations

### List User Organizations

```go
organizations, err := client.Organizations.List(accessToken)
```

### Get Organization

```go
org, err := client.Organizations.Get("org-id")
```

### Create Organization

```go
org, err := client.Organizations.Create(&protekt.CreateOrganizationRequest{
    Name:        "My Organization",
    DisplayName: "My Org Display Name",
})
```

## Roles and Permissions

### List Roles

```go
roles, err := client.Roles.List()
```

### Create Role

```go
role, err := client.Roles.Create(&protekt.CreateRoleRequest{
    Name:        "admin",
    Description: "Administrator role",
    Permissions: []string{"read:users", "write:users", "delete:users"},
})
```

### Assign Role to User

```go
err := client.Roles.AssignToUser("user-id", "role-id")
```

## Multi-Factor Authentication

### Enable MFA

```go
// Enable TOTP
totpSetup, err := client.MFA.EnableTOTP(accessToken)

// Enable SMS
err := client.MFA.EnableSMS(accessToken, "+1234567890")

// Enable WebAuthn
webauthnSetup, err := client.MFA.EnableWebAuthn(accessToken)
```

### Verify MFA

```go
// Verify TOTP code
err := client.MFA.VerifyTOTP(accessToken, "123456")

// Verify SMS code
err := client.MFA.VerifySMS(accessToken, "123456")
```

## Error Handling

```go
user, err := client.Auth.Login(&protekt.LoginRequest{
    Email:    "user@example.com",
    Password: "wrong-password",
})
if err != nil {
    if protekt.IsError(err, "INVALID_CREDENTIALS") {
        fmt.Println("Invalid email or password")
    } else if protekt.IsError(err, "MFA_REQUIRED") {
        fmt.Println("MFA verification required")
    } else {
        fmt.Printf("Unexpected error: %v\n", err)
    }
}
```

## HTTP Client Configuration

```go
client := protekt.NewClient(&protekt.Config{
    Domain:       "your-tenant.protekt.com",
    ClientID:     "your-client-id",
    ClientSecret: "your-client-secret",
    HTTPClient: &http.Client{
        Timeout: 30 * time.Second,
    },
})
```

## Gin Integration

```go
package main

import (
    "github.com/gin-gonic/gin"
    "github.com/protekt/go"
)

func main() {
    r := gin.Default()
    client := protekt.NewClient(&protekt.Config{
        Domain:       "your-tenant.protekt.com",
        ClientID:     "your-client-id",
        ClientSecret: "your-client-secret",
        RedirectURI:  "http://localhost:8080/callback",
    })

    // Login page
    r.GET("/login", func(c *gin.Context) {
        authURL := client.Auth.GetAuthorizationURL(&protekt.AuthorizationURLRequest{
            Scope: "openid profile email",
        })
        c.Redirect(http.StatusFound, authURL)
    })

    // OAuth callback
    r.GET("/callback", func(c *gin.Context) {
        tokens, err := client.Auth.HandleCallback(c.Request.URL.Query())
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        user, err := client.Auth.GetUser(tokens.AccessToken)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Store in session
        c.SetCookie("access_token", tokens.AccessToken, 3600, "/", "", false, true)
        c.SetCookie("user_id", user.ID, 3600, "/", "", false, true)

        c.Redirect(http.StatusFound, "/dashboard")
    })

    // Protected route
    r.GET("/dashboard", func(c *gin.Context) {
        accessToken, err := c.Cookie("access_token")
        if err != nil {
            c.Redirect(http.StatusFound, "/login")
            return
        }

        user, err := client.Auth.GetUser(accessToken)
        if err != nil {
            c.Redirect(http.StatusFound, "/login")
            return
        }

        c.JSON(http.StatusOK, gin.H{"user": user})
    })

    r.Run(":8080")
}
```

## Echo Integration

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
    "github.com/protekt/go"
)

func main() {
    e := echo.New()
    client := protekt.NewClient(&protekt.Config{
        Domain:       "your-tenant.protekt.com",
        ClientID:     "your-client-id",
        ClientSecret: "your-client-secret",
        RedirectURI:  "http://localhost:8080/callback",
    })

    // Login page
    e.GET("/login", func(c echo.Context) error {
        authURL := client.Auth.GetAuthorizationURL(&protekt.AuthorizationURLRequest{
            Scope: "openid profile email",
        })
        return c.Redirect(http.StatusFound, authURL)
    })

    // OAuth callback
    e.GET("/callback", func(c echo.Context) error {
        tokens, err := client.Auth.HandleCallback(c.QueryParams())
        if err != nil {
            return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
        }

        user, err := client.Auth.GetUser(tokens.AccessToken)
        if err != nil {
            return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
        }

        // Store in session
        c.SetCookie(&http.Cookie{
            Name:     "access_token",
            Value:    tokens.AccessToken,
            MaxAge:   3600,
            Path:     "/",
            HttpOnly: true,
        })

        return c.Redirect(http.StatusFound, "/dashboard")
    })

    // Protected route
    e.GET("/dashboard", func(c echo.Context) error {
        cookie, err := c.Cookie("access_token")
        if err != nil {
            return c.Redirect(http.StatusFound, "/login")
        }

        user, err := client.Auth.GetUser(cookie.Value)
        if err != nil {
            return c.Redirect(http.StatusFound, "/login")
        }

        return c.JSON(http.StatusOK, map[string]interface{}{"user": user})
    })

    e.Start(":8080")
}
```

## Middleware

### Authentication Middleware

```go
func AuthMiddleware(client *protekt.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        accessToken, err := c.Cookie("access_token")
        if err != nil {
            c.Redirect(http.StatusFound, "/login")
            c.Abort()
            return
        }

        user, err := client.Auth.GetUser(accessToken)
        if err != nil {
            c.Redirect(http.StatusFound, "/login")
            c.Abort()
            return
        }

        c.Set("user", user)
        c.Next()
    }
}

// Usage
r.GET("/protected", AuthMiddleware(client), func(c *gin.Context) {
    user := c.MustGet("user").(*protekt.User)
    c.JSON(http.StatusOK, gin.H{"message": "Hello, " + user.Name})
})
```

## WebSocket Support

```go
package main

import (
    "github.com/gorilla/websocket"
    "github.com/protekt/go"
    "net/http"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true
    },
}

func websocketHandler(client *protekt.Client) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil {
            return
        }
        defer conn.Close()

        // Get access token from query params or headers
        accessToken := r.URL.Query().Get("token")

        // Verify token
        user, err := client.Auth.GetUser(accessToken)
        if err != nil {
            conn.WriteJSON(map[string]string{"error": "Invalid token"})
            return
        }

        // Handle WebSocket messages
        for {
            var message map[string]interface{}
            err := conn.ReadJSON(&message)
            if err != nil {
                break
            }

            // Process message
            conn.WriteJSON(map[string]interface{}{
                "user": user,
                "message": message,
            })
        }
    }
}
```

## Context Support

```go
func getUserWithContext(ctx context.Context, client *protekt.Client, accessToken string) (*protekt.User, error) {
    return client.Auth.GetUserWithContext(ctx, accessToken)
}

// Usage with timeout
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

user, err := getUserWithContext(ctx, client, accessToken)
```

## Examples

### Complete Authentication Flow

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "github.com/gin-gonic/gin"
    "github.com/protekt/go"
)

func main() {
    r := gin.Default()
    client := protekt.NewClient(&protekt.Config{
        Domain:       "your-tenant.protekt.com",
        ClientID:     "your-client-id",
        ClientSecret: "your-client-secret",
        RedirectURI:  "http://localhost:8080/callback",
    })

    // Login page
    r.GET("/login", func(c *gin.Context) {
        authURL := client.Auth.GetAuthorizationURL(&protekt.AuthorizationURLRequest{
            Scope: "openid profile email",
        })
        c.Redirect(http.StatusFound, authURL)
    })

    // OAuth callback
    r.GET("/callback", func(c *gin.Context) {
        tokens, err := client.Auth.HandleCallback(c.Request.URL.Query())
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        user, err := client.Auth.GetUser(tokens.AccessToken)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Store in session
        c.SetCookie("access_token", tokens.AccessToken, 3600, "/", "", false, true)
        c.SetCookie("user_id", user.ID, 3600, "/", "", false, true)

        c.Redirect(http.StatusFound, "/dashboard")
    })

    // Dashboard
    r.GET("/dashboard", func(c *gin.Context) {
        accessToken, err := c.Cookie("access_token")
        if err != nil {
            c.Redirect(http.StatusFound, "/login")
            return
        }

        user, err := client.Auth.GetUser(accessToken)
        if err != nil {
            c.Redirect(http.StatusFound, "/login")
            return
        }

        c.JSON(http.StatusOK, gin.H{"user": user})
    })

    // Logout
    r.GET("/logout", func(c *gin.Context) {
        c.SetCookie("access_token", "", -1, "/", "", false, true)
        c.SetCookie("user_id", "", -1, "/", "", false, true)
        c.Redirect(http.StatusFound, "/login")
    })

    fmt.Println("Server running on http://localhost:8080")
    log.Fatal(r.Run(":8080"))
}
```

## API Reference

For detailed API documentation, see the [API Reference](/reference/redocusaurus).

## Support

- **Documentation**: [docs.protekt.com](https://docs.protekt.com)
- **GitHub**: [github.com/protekt/go](https://github.com/protekt/go)
- **Go Modules**: [pkg.go.dev/github.com/protekt/go](https://pkg.go.dev/github.com/protekt/go)
- **Support**: [support@protekt.com](mailto:support@protekt.com) 